# Go言語で学ぶ並行プログラミングの写経

本: [Go言語で学ぶ並行プログラミング　他言語にも適用できる原則とベストプラクティス \- インプレスブックス](https://book.impress.co.jp/books/1123101144)

原著: [Learn Concurrent Programming with Go](https://learning.oreilly.com/library/view/learn-concurrent-programming/9781633438385/)

原著GitHub: [cutajarj/ConcurrentProgrammingWithGo: Listings from manning book](https://github.com/cutajarj/ConcurrentProgrammingWithGo)

## まとめ・感想

### 第1章 並行プログラミング

並行プログラミングの総論的内容。

- Goには並行プログラミングを実現する仕組みとしてゴルーチンがある
- ゴルーチンはCSPという思想の実現化
- CSP方式のモデルを使うことである種の並行プログラミングのエラーを減らせる
- アムダールの法則により実行の非並列部分により水平方向のスケーラビリティに制限がかかることが知られている。
- アムダールの法則への反論としてグスタフンの法則がある

感想:

並列、並行プログラミングの問題についての知識があれば斜め読みで良いだろう。

### 第2章 スレッドを扱う

- プロセスの概略
- スレッドの概略
  - OS（カーネルレベル）スレッドとユーザースレッドについての説明
  - ユーザースレッドはユーザー空間で作られ管理されるスレッドのこと
  - カーネルレベルスレッドに比べ軽量でコンテキストスイッチも素早く実行できるが、1つのプロセッサ内でしか動作できないなどの制約がある。
- ゴルーチンについて
  - ゴルーチンの現在の実装は直接OSスレッドには紐付かない
  - ゴルーチンはOSスレッドとユーザースレッドのハイブリッドシステムで実行管理されている
  - ゴルーチンは複数のユーザーレベルスレッドを複数のカーネルレベルスレッドにマッピングされる
  - この仕組みはM:Nスレッディングモデルと言われることがある
  - ゴルーチンはカーネルレベルスレッドの集まりを使い、それぞれがゴルーチンのキューを管理することで実現している。複数のカーネルレベルスレッドがあるので、複数のCPUを使う事ができる
  - GOMAXPROCSという環境変数でGoランタイムが使用するカーネルレベルスレッド数を設定することができ、通常は動作するマシンの論理プロセッサ数代わり当てられる（ch02/03_listing2.4）
  - Goランタイムはカーネルレベルスレッドにローカル実行キュー（LRQ: Local Run Queue）を割り当てる
  - また、Goランタイムはカーネルレベルスレッドに割り当てていないゴルーチンのためにグローバル実行キュー（GRQ: Global Run Queue）を持っている
  - 各カーネルレベルスレッドはLRQに入っているゴルーチンを取り出し実行する
  - あるスレッドでブロッキングが発生しそうになると、Goランタイムは新たなカーネルレベルスレッドを作るか再利用して新たなスレッドに新しいLRQを割り当てる。ブロッキングが発生したスレッドのLRQにいたゴルーチンはこの新しいLRQ
    に移動する。これをワークスティーリングと呼ぶ。
  - ワークスティーリングはブロッキング時だけではなく、キュー内のスレッドの数が不均衡な場合にも行われる
  - GoのスケジューラーがGoルーチンを切り替えるタイミングはユーザーレベルのイベントを必要とする。具体的には新たなゴルーチンの開始、システムコールの実行（たとえばファイル読み込み）、ゴルーチンの同期など
  - コード内でGoスケジューラーを呼び出して、スケジューラーに別のゴルーチンへのコンテキストスイッチをさせるよう試みることができる（ch02/04_listing2.5）
- 並列性と平行性について
  - 平行性: プログラムコードの特性
  - 並列性: 実行プログラムの特性

感想:

ゴルーチンのスケジューリングに関して理解できて良かった。

### 第3章 メモリ共有を使ったスレッド間通信

- メモリ共有
  - メモリ共有は複数のスレッドで一つの帆ワイドボードを共有するようなもの
  - 実際の計算機でメモリ共有が行われている仕組みについての解説
  - ポインタを使ったゴルーチン間でのメモリ共有（ch03/01_listing3.1）
  - Goのコンパイラはゴルーチン間で共有されているものを発見すると、（一見スタックにあるように見えても）それをスタックではなくヒープに置く
  - `go build -gcflags="-m" countdown.go`こうするとどの変数がヒープに置かれたのかわかる
  - 複数のゴルーチンから単純に同じヒープの値に書き込みを行うと**競合状態**が発生し正しい処理結果を得ることが出来ない。場合によっては深刻な事態となる
  - 競合状態はプログラムが同時に多くのことを行おうとし、その動作が独立した予測不可能なイベントも関わらず、正確なタイミングで行う必要がある場合に起こる
  - 競合状態はハイゼンバグ（Heisenbug）の良い例。ハイゼンバグは量子力学のハイゼンベルグの不確定性原理から名付けられていて、デバッグして切り分けようとすると消えてしまったり、挙動が変わってしまうバグのこと
  - **アトミック**: 分割できないこと。アトミック操作は分割できない操作のこと
  - **クリティカルセクション**: そのセクションで使われている状態に影響を与える他の実行からの干渉を受けずに実行される命令の集まり
  -   - クリティカルセクションの外でGoのスケジューラーを起動しても解決策にはならない（ch03/05_listing3.7）
  - 適切な同期と通信による競合状態の排除
    - 最初のステップはこの問題に対して適切なツールを使っているかの確認。本当にメモリ共有は正しい方法なのか。チャネルとCSPを使う方が適切ではないのか
    - 第2ステップは競合状態がいつ発生するか認識をすること。
  - `go run -race stingyspendysched.go`のように`-race`オプションを就けて実行させることでGoに競合状態を検出させられる。

感想:

単純なメモリ共有で競合状態が容易に発生してしまうことが理解できる。また`-race`オプションについて具体的に学べるのが良い。

### 第4章 ミューテックスを使った同期

- クリティカルセクションを**ミューテックス**で保護することで、一度の1つのゴルーチンだけが共有資源にアクセスできるようになる。そうすることで競合状態を排除できる。
- ミューテックスの変形は**ロック**と呼ばれることもあり、並行プログラミングをサポートする全ての言語で使われている。
- ゴルーチンがミューテックスで保護されたコードのクリティカルセクションに到達すると、プログラムコード内の命令としてミューテックスをロックする、その後、ゴルーチンはクリティカルセクション内のコードの実行を開始し、終了するとミューテックスをアンロックする。
- ミューテックスがロックされている間は他のゴルーチンはクリティカルセクションにアクセスする事ができない。
- 既にロックされているミューテックスを他のゴルーチンがロックしようとすると、そのゴルーチンはそのミューテックスがアンロックするまで待機する。
- ロックの開放を待って2つ以上のゴルーチンが待機している場合には、ロックが介抱さっれると1つのゴルーチンだけが再開して、残りのゴルーチンは待たされる。
- ミューテックス（mutex）は相互排他（mutual exclusion）の略
- Goではミューテックスの機能は`sync`パッケージの`Mutex`型で提供されている。この方は`Lock()`と`Unlock()
`という2つの主要メソッドがあり、それぞれクリティカルセクションの開始と終了を示すのに使用できる。コード例（ch04/01_listing4.1_2）
- ミューテックスの機能はOSとハードウェアにより実現されている。
- 参考: [sync\.Mutexの仕組みを理解する \- Speaker Deck](https://speakerdeck.com/ffjlabo/sync-dot-mutexnoshi-zu-miwoli-jie-suru)
- ミューテックスによるロック範囲は適切に設定しないと、ゴルーチンの切り替え待ちの待ち時間が増え、全体として処理が遅くなってしまう。（ch04/02_listing4.3_4）
- ロックの範囲が適切になりように修正した例（ch04/03_listing4.5）
- ノンブロッキング・ミューテックス・ロック：ロックが可能かどうか確認し、ロックが不可能な場合には別の処理を行うこと。
  - Goには`TryLock()`関数があり、ロックを取得可能か確認出来る
  - `TryLock()`を使う1例は、特定のタスクの進行を妨げずにそのタスクの進行状況を確認するモニターゴルーチンがある。
  - サンプル（ch04/04_listing4.6）
- リーダー・ライダー・ミューテックスによる性能向上
  - リーダー・ライター・ミューテックス（readers-writer mutex）は、共有資源を更新する必要がある場合のみ並行処理を制限する、標準的なミューテックスの変形。
  - Goではリーダー・ライター・ミューテックスの実装として`sync.RWMutex`がある。通常の排他的ロックメソッドと排他的アンロックメソッドに加え、ミューテックスのリーダー側を使う為のメソッド、`RLock()`, 
    `RLocker()`, `RUnlock()`が用意されている。
  - リーダーミューテックスはクリティカルセクションを走査している間にデータ構造が変更されないようにするために必要。
  - ライターミューテックスは他からの書き込みは制限するが、読み込みは制限しない。
  - サンプル（ch04/06_listing4.10_11）

感想:

ミューテックスの仕組みが理解できる。

### 第5章 条件変数とセマフォ

- **条件変数**: 条件編集はミューテックスの上に追加の機能を提供する。この機能はゴルーチンが特定の条件が発生するのを待つ状況で使用できる。
  - Goの条件変数の実装は`sync.Cond`型。Goで新たな条件変数を作るには`Locker`インテーフェイスをもったインスタンスが必要。コード例（ch05/03_listing5.3_4_5）
  - 参考: [sync package \- sync \- Go Packages](https://pkg.go.dev/sync#Cond)
  - ゴルーチンが`Signal()`もしくは`Broadcast()`を呼び出したときに`Wait()`で待機していないゴルーチンがいない場合にはそのシグナルは失われる。
  - `Signal()`は待機している中から1つのゴルーチンだけを呼び出し、`Broadcast()`は`Wait()`で待機している全てのゴルーチンを呼び出す。
  - **スターベーション**（starvation）とは、他の貪欲な実行によって資源が長時間もしくは無期限に利用できなくなり、共有資源へのアクセスを得ることが出来ない状況。（ch05/07_listing5.10）
  - スターベーションを起こさないようにするには、ゴルーチンをミューテックスで待たせる代わりに、条件変数を使って一時停止させる。
- **セマフォ**: セマフォ（semaphore）は、並行実行の許容数を指定できる点で、異なる種類の並行実行制御を提供する。
  - セマフォは共有資源へのアクセスを並行実行できるようにする固定数の許可を可能にする。全ての許可が使われると、1つの許可が再び開放されるまで、それ以上のアクセス要求は待機する必要がある。
  - ミューテックスは、排他的にアクセスできるゴルーチンが1つだけあることを保障するのに対して、セマフォは最大N個のゴルーチンがアクセスできることを保証する
  - 許可が1つしかないセマフォは、バイナリセマフォ（binary semaphore）と呼ばれる。
  - セマフォには準標準ライブラリがある [semaphore package \- golang\.org/x/sync/semaphore \- Go Packages](https://pkg.go.dev/golangorg/x/sync/semaphore)
  - 理解のための実装例（ch05/09_listing5.16､ch05/10_listing5.18）
  - 重み付けセマフォ（weighted semaphore）は、複数の許可を同時に獲得および開放するセマフォの一種（ch05/13_exam03）

感想:

条件変数とセマフォについて理解できる。

### 第6章 ウェイトグループとバリアを使った同期

- **ウェイトグループ**（weight group）と**バリア**（barrier）は、複数のゴルーチンといった実行の集まりに対して同期抽象化を行う機能のこと。
- ウェイトグループを使うと、並行タスクの集まりが完了するまでゴルーチンを待機させられる。
- Goの標準ライブラリには`sync`パッケージに`WaitGroup`型がある。この型には`Done()`, `Wait()`, `Add(delta int)`の3つのメソッドがある。
  - `Done()`: ウェイトグループのカウンタを1つ減らす。
  - `Wait()`: ウェイトグループのカウンタが0になるまで待つ
  - `Add(delta int)`: ウェイトグループのカウンタをdelta分増やす
  - 参考例（ch06/02_listing6.2）
  - 処理途中でウェイトグループのカウンタの加算が必要な例（ch06/05_listing6.5_6）
- バリアは、コード内の特定の場所でゴルーチンのグループを同期させる機能を提供する。
  - 実装によってはバリアを複数回再利用でき、再利用可能なバリアを循環式バリア（cycle barrier）と呼ぶ

感想:

ウェイトグループとバリアの使用方法や使用すべき箇所が解った。

### 第7章 メッセージパッシングを使った通信


