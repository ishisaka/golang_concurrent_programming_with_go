# Go言語で学ぶ並行プログラミングの写経

本: [Go言語で学ぶ並行プログラミング　他言語にも適用できる原則とベストプラクティス \- インプレスブックス](https://book.impress.co.jp/books/1123101144)

原著: [Learn Concurrent Programming with Go](https://learning.oreilly.com/library/view/learn-concurrent-programming/9781633438385/)

原著GitHub: [cutajarj/ConcurrentProgrammingWithGo: Listings from manning book](https://github.com/cutajarj/ConcurrentProgrammingWithGo)

## まとめ・感想

### 第1章 並行プログラミング

並行プログラミングの総論的内容。

- Goには並行プログラミングを実現する仕組みとしてゴルーチンがある
- ゴルーチンはCSPという思想の実現化
- CSP方式のモデルを使うことである種の並行プログラミングのエラーを減らせる
- アムダールの法則により実行の非並列部分により水平方向のスケーラビリティに制限がかかることが知られている。
- アムダールの法則への反論としてグスタフンの法則がある

感想:

並列、並行プログラミングの問題についての知識があれば斜め読みで良いだろう。

### 第2章 スレッドを扱う

- プロセスの概略
- スレッドの概略
  - OS（カーネルレベル）スレッドとユーザースレッドについての説明
  - ユーザースレッドはユーザー空間で作られ管理されるスレッドのこと
  - カーネルレベルスレッドに比べ軽量でコンテキストスイッチも素早く実行できるが、1つのプロセッサ内でしか動作できないなどの制約がある。
- ゴルーチンについて
  - ゴルーチンの現在の実装は直接OSスレッドには紐付かない
  - ゴルーチンはOSスレッドとユーザースレッドのハイブリッドシステムで実行管理されている
  - ゴルーチンは複数のユーザーレベルスレッドを複数のカーネルレベルスレッドにマッピングされる
  - この仕組みはM:Nスレッディングモデルと言われることがある
  - ゴルーチンはカーネルレベルスレッドの集まりを使い、それぞれがゴルーチンのキューを管理することで実現している。複数のカーネルレベルスレッドがあるので、複数のCPUを使う事ができる
  - GOMAXPROCSという環境変数でGoランタイムが使用するカーネルレベルスレッド数を設定することができ、通常は動作するマシンの論理プロセッサ数代わり当てられる（ch02/03_listing2.4）
  - Goランタイムはカーネルレベルスレッドにローカル実行キュー（LRQ: Local Run Queue）を割り当てる
  - また、Goランタイムはカーネルレベルスレッドに割り当てていないゴルーチンのためにグローバル実行キュー（GRQ: Global Run Queue）を持っている
  - 各カーネルレベルスレッドはLRQに入っているゴルーチンを取り出し実行する
  - あるスレッドでブロッキングが発生しそうになると、Goランタイムは新たなカーネルレベルスレッドを作るか再利用して新たなスレッドに新しいLRQを割り当てる。ブロッキングが発生したスレッドのLRQにいたゴルーチンはこの新しいLRQ
    に移動する。これをワークスティーリングと呼ぶ。
  - ワークスティーリングはブロッキング時だけではなく、キュー内のスレッドの数が不均衡な場合にも行われる
  - GoのスケジューラーがGoルーチンを切り替えるタイミングはユーザーレベルのイベントを必要とする。具体的には新たなゴルーチンの開始、システムコールの実行（たとえばファイル読み込み）、ゴルーチンの同期など
  - コード内でGoスケジューラーを呼び出して、スケジューラーに別のゴルーチンへのコンテキストスイッチをさせるよう試みることができる（ch02/04_listing2.5）
- 並列性と平行性について
  - 平行性: プログラムコードの特性
  - 並列性: 実行プログラムの特性

感想:

ゴルーチンのスケジューリングに関して理解できて良かった。

### 第3章 メモリ共有を使ったスレッド間通信

- メモリ共有
  - メモリ共有は複数のスレッドで一つの帆ワイドボードを共有するようなもの
  - 実際の計算機でメモリ共有が行われている仕組みについての解説
  - ポインタを使ったゴルーチン間でのメモリ共有（ch03/01_listing3.1）
  - Goのコンパイラはゴルーチン間で共有されているものを発見すると、（一見スタックにあるように見えても）それをスタックではなくヒープに置く
  - `go build -gcflags="-m" countdown.go`こうするとどの変数がヒープに置かれたのかわかる
  - 複数のゴルーチンから単純に同じヒープの値に書き込みを行うと**競合状態**が発生し正しい処理結果を得ることが出来ない。場合によっては深刻な事態となる
  - 競合状態はプログラムが同時に多くのことを行おうとし、その動作が独立した予測不可能なイベントも関わらず、正確なタイミングで行う必要がある場合に起こる
  - 競合状態はハイゼンバグ（Heisenbug）の良い例。ハイゼンバグは量子力学のハイゼンベルグの不確定性原理から名付けられていて、デバッグして切り分けようとすると消えてしまったり、挙動が変わってしまうバグのこと
  - **アトミック**: 分割できないこと。アトミック操作は分割できない操作のこと
  - **クリティカルセクション**: そのセクションで使われている状態に影響を与える他の実行からの干渉を受けずに実行される命令の集まり
  -   - クリティカルセクションの外でGoのスケジューラーを起動しても解決策にはならない（ch03/05_listing3.7）
  - 適切な同期と通信による競合状態の排除
    - 最初のステップはこの問題に対して適切なツールを使っているかの確認。本当にメモリ共有は正しい方法なのか。チャネルとCSPを使う方が適切ではないのか
    - 第2ステップは競合状態がいつ発生するか認識をすること。
  - `go run -race stingyspendysched.go`のように`-race`オプションを就けて実行させることでGoに競合状態を検出させられる。

感想:

単純なメモリ共有で競合状態が容易に発生してしまうことが理解できる。また`-race`オプションについて具体的に学べるのが良い。

