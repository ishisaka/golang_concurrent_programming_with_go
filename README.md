# Go言語で学ぶ並行プログラミングの写経

本: [Go言語で学ぶ並行プログラミング　他言語にも適用できる原則とベストプラクティス \- インプレスブックス](https://book.impress.co.jp/books/1123101144)

原著: [Learn Concurrent Programming with Go](https://learning.oreilly.com/library/view/learn-concurrent-programming/9781633438385/)

原著GitHub: [cutajarj/ConcurrentProgrammingWithGo: Listings from manning book](https://github.com/cutajarj/ConcurrentProgrammingWithGo)

## まとめ・感想

### 第1章 並行プログラミング

並行プログラミングの総論的内容。

- Goには並行プログラミングを実現する仕組みとしてゴルーチンがある
- ゴルーチンはCSPという思想の実現化
- CSP方式のモデルを使うことである種の並行プログラミングのエラーを減らせる
- アムダールの法則により実行の非並列部分により水平方向のスケーラビリティに制限がかかることが知られている。
- アムダールの法則への反論としてグスタフンの法則がある

感想:

並列、並行プログラミングの問題についての知識があれば斜め読みで良いだろう。

### 第2章 スレッドを扱う

- プロセスの概略
- スレッドの概略
  - OS（カーネルレベル）スレッドとユーザースレッドについての説明
  - ユーザースレッドはユーザー空間で作られ管理されるスレッドのこと
  - カーネルレベルスレッドに比べ軽量でコンテキストスイッチも素早く実行できるが、1つのプロセッサ内でしか動作できないなどの制約がある。
- ゴルーチンについて
  - ゴルーチンの現在の実装は直接OSスレッドには紐付かない
  - ゴルーチンはOSスレッドとユーザースレッドのハイブリッドシステムで実行管理されている
  - ゴルーチンは複数のユーザーレベルスレッドを複数のカーネルレベルスレッドにマッピングされる
  - この仕組みはM:Nスレッディングモデルと言われることがある
  - ゴルーチンはカーネルレベルスレッドの集まりを使い、それぞれがゴルーチンのキューを管理することで実現している。複数のカーネルレベルスレッドがあるので、複数のCPUを使う事ができる
  - GOMAXPROCSという環境変数でGoランタイムが使用するカーネルレベルスレッド数を設定することができ、通常は動作するマシンの論理プロセッサ数代わり当てられる（ch02/03_listing2.4）
  - Goランタイムはカーネルレベルスレッドにローカル実行キュー（LRQ: Local Run Queue）を割り当てる
  - また、Goランタイムはカーネルレベルスレッドに割り当てていないゴルーチンのためにグローバル実行キュー（GRQ: Global Run Queue）を持っている
  - 各カーネルレベルスレッドはLRQに入っているゴルーチンを取り出し実行する
  - あるスレッドでブロッキングが発生しそうになると、Goランタイムは新たなカーネルレベルスレッドを作るか再利用して新たなスレッドに新しいLRQを割り当てる。ブロッキングが発生したスレッドのLRQにいたゴルーチンはこの新しいLRQ
    に移動する。これをワークスティーリングと呼ぶ。
  - ワークスティーリングはブロッキング時だけではなく、キュー内のスレッドの数が不均衡な場合にも行われる
  - GoのスケジューラーがGoルーチンを切り替えるタイミングはユーザーレベルのイベントを必要とする。具体的には新たなゴルーチンの開始、システムコールの実行（たとえばファイル読み込み）、ゴルーチンの同期など
  - コード内でGoスケジューラーを呼び出して、スケジューラーに別のゴルーチンへのコンテキストスイッチをさせるよう試みることができる（ch02/04_listing2.5）
- 並列性と平行性について
  - 平行性: プログラムコードの特性
  - 並列性: 実行プログラムの特性

感想:

ゴルーチンのスケジューリングに関して理解できて良かった。
