# Go言語で学ぶ並行プログラミングの写経

本: [Go言語で学ぶ並行プログラミング　他言語にも適用できる原則とベストプラクティス \- インプレスブックス](https://book.impress.co.jp/books/1123101144)

原著: [Learn Concurrent Programming with Go](https://learning.oreilly.com/library/view/learn-concurrent-programming/9781633438385/)

原著GitHub: [cutajarj/ConcurrentProgrammingWithGo: Listings from manning book](https://github.com/cutajarj/ConcurrentProgrammingWithGo)

## まとめ・感想

### 第1章 並行プログラミング

並行プログラミングの総論的内容。

- Goには並行プログラミングを実現する仕組みとしてゴルーチンがある
- ゴルーチンはCSPという思想の実現化
- CSP方式のモデルを使うことである種の並行プログラミングのエラーを減らせる
- アムダールの法則により実行の非並列部分により水平方向のスケーラビリティに制限がかかることが知られている。
- アムダールの法則への反論としてグスタフンの法則がある

感想:

並列、並行プログラミングの問題についての知識があれば斜め読みで良いだろう。

### 第2章 スレッドを扱う

- プロセスの概略
- スレッドの概略
  - OS（カーネルレベル）スレッドとユーザースレッドについての説明
  - ユーザースレッドはユーザー空間で作られ管理されるスレッドのこと
  - カーネルレベルスレッドに比べ軽量でコンテキストスイッチも素早く実行できるが、1つのプロセッサ内でしか動作できないなどの制約がある。
- ゴルーチンについて
  - ゴルーチンの現在の実装は直接OSスレッドには紐付かない
  - ゴルーチンはOSスレッドとユーザースレッドのハイブリッドシステムで実行管理されている
  - ゴルーチンは複数のユーザーレベルスレッドを複数のカーネルレベルスレッドにマッピングされる
  - この仕組みはM:Nスレッディングモデルと言われることがある
  - ゴルーチンはカーネルレベルスレッドの集まりを使い、それぞれがゴルーチンのキューを管理することで実現している。複数のカーネルレベルスレッドがあるので、複数のCPUを使う事ができる
  - GOMAXPROCSという環境変数でGoランタイムが使用するカーネルレベルスレッド数を設定することができ、通常は動作するマシンの論理プロセッサ数代わり当てられる（ch02/03_listing2.4）
  - Goランタイムはカーネルレベルスレッドにローカル実行キュー（LRQ: Local Run Queue）を割り当てる
  - また、Goランタイムはカーネルレベルスレッドに割り当てていないゴルーチンのためにグローバル実行キュー（GRQ: Global Run Queue）を持っている
  - 各カーネルレベルスレッドはLRQに入っているゴルーチンを取り出し実行する
  - あるスレッドでブロッキングが発生しそうになると、Goランタイムは新たなカーネルレベルスレッドを作るか再利用して新たなスレッドに新しいLRQを割り当てる。ブロッキングが発生したスレッドのLRQにいたゴルーチンはこの新しいLRQ
    に移動する。これをワークスティーリングと呼ぶ。
  - ワークスティーリングはブロッキング時だけではなく、キュー内のスレッドの数が不均衡な場合にも行われる
  - GoのスケジューラーがGoルーチンを切り替えるタイミングはユーザーレベルのイベントを必要とする。具体的には新たなゴルーチンの開始、システムコールの実行（たとえばファイル読み込み）、ゴルーチンの同期など
  - コード内でGoスケジューラーを呼び出して、スケジューラーに別のゴルーチンへのコンテキストスイッチをさせるよう試みられる。（ch02/04_listing2.5）
- 並列性と平行性について
  - 平行性: プログラムコードの特性
  - 並列性: 実行プログラムの特性

感想:

ゴルーチンのスケジューリングに関して理解できて良かった。

### 第3章 メモリ共有を使ったスレッド間通信

- メモリ共有
  - メモリ共有は複数のスレッドで一つの帆ワイドボードを共有するようなもの
  - 実際の計算機でメモリ共有が行われている仕組みについての解説
  - ポインタを使ったゴルーチン間でのメモリ共有（ch03/01_listing3.1）
  - Goのコンパイラはゴルーチン間で共有されているものを発見すると、（一見スタックにあるように見えても）それをスタックではなくヒープに置く
  - `go build -gcflags="-m" countdown.go`こうするとどの変数がヒープに置かれたのかわかる
  - 複数のゴルーチンから単純に同じヒープの値に書き込みを行うと**競合状態**が発生し正しい処理結果を得られない。場合によっては深刻な事態となる
  - 競合状態はプログラムが同時に多くのことを行おうとし、その動作が独立した予測不可能なイベントも関わらず、正確なタイミングで行う必要がある場合に起こる
  - 競合状態はハイゼンバグ（Heisenbug）の良い例。ハイゼンバグは量子力学のハイゼンベルグの不確定性原理から名付けられていて、デバッグして切り分けようとすると消えてしまったり、挙動が変わってしまうバグのこと
  - **アトミック**: 分割できないこと。アトミック操作は分割できない操作のこと
  - **クリティカルセクション**: そのセクションで使われている状態に影響を与える他の実行からの干渉を受けずに実行される命令の集まり
  -   - クリティカルセクションの外でGoのスケジューラーを起動しても解決策にはならない（ch03/05_listing3.7）
  - 適切な同期と通信による競合状態の排除
    - 最初のステップはこの問題に対して適切なツールを使っているかの確認。本当にメモリ共有は正しい方法なのか。チャネルとCSPを使う方が適切ではないのか
    - 第2ステップは競合状態がいつ発生するか認識をすること。
  - `go run -race stingyspendysched.go`のように`-race`オプションを就けて実行させることでGoに競合状態を検出させられる。

感想:

単純なメモリ共有で競合状態が容易に発生してしまうことが理解できる。また`-race`オプションについて具体的に学べるのが良い。

### 第4章 ミューテックスを使った同期

- クリティカルセクションを**ミューテックス**で保護することで、一度の1つのゴルーチンだけが共有資源にアクセスできるようになる。そうすることで競合状態を排除できる。
- ミューテックスの変形は**ロック**と呼ばれることもあり、並行プログラミングをサポートする全ての言語で使われている。
- ゴルーチンがミューテックスで保護されたコードのクリティカルセクションに到達すると、プログラムコード内の命令としてミューテックスをロックする、その後、ゴルーチンはクリティカルセクション内のコードの実行を開始し、終了するとミューテックスをアンロックする。
- ミューテックスがロックされている間は他のゴルーチンはクリティカルセクションにアクセスする事ができない。
- 既にロックされているミューテックスを他のゴルーチンがロックしようとすると、そのゴルーチンはそのミューテックスがアンロックするまで待機する。
- ロックの開放を待って2つ以上のゴルーチンが待機している場合には、ロックが介抱さっれると1つのゴルーチンだけが再開して、残りのゴルーチンは待たされる。
- ミューテックス（mutex）は相互排他（mutual exclusion）の略
- Goではミューテックスの機能は`sync`パッケージの`Mutex`型で提供されている。この方は`Lock()`と`Unlock()
`という2つの主要メソッドがあり、それぞれクリティカルセクションの開始と終了を示すのに使用できる。コード例（ch04/01_listing4.1_2）
- ミューテックスの機能はOSとハードウェアにより実現されている。
- 参考: [sync\.Mutexの仕組みを理解する \- Speaker Deck](https://speakerdeck.com/ffjlabo/sync-dot-mutexnoshi-zu-miwoli-jie-suru)
- ミューテックスによるロック範囲は適切に設定しないと、ゴルーチンの切り替え待ちの待ち時間が増え、全体として処理が遅くなってしまう。（ch04/02_listing4.3_4）
- ロックの範囲が適切になりように修正した例（ch04/03_listing4.5）
- ノンブロッキング・ミューテックス・ロック：ロックが可能かどうか確認し、ロックが不可能な場合には別の処理を行うこと。
  - Goには`TryLock()`関数があり、ロックを取得可能か確認出来る
  - `TryLock()`を使う1例は、特定のタスクの進行を妨げずにそのタスクの進行状況を確認するモニターゴルーチンがある。
  - サンプル（ch04/04_listing4.6）
- リーダー・ライダー・ミューテックスによる性能向上
  - リーダー・ライター・ミューテックス（readers-writer mutex）は、共有資源を更新する必要がある場合のみ並行処理を制限する、標準的なミューテックスの変形。
  - Goではリーダー・ライター・ミューテックスの実装として`sync.RWMutex`がある。通常の排他的ロックメソッドと排他的アンロックメソッドに加え、ミューテックスのリーダー側を使う為のメソッド、`RLock()`, 
    `RLocker()`, `RUnlock()`が用意されている。
  - リーダーミューテックスはクリティカルセクションを走査している間にデータ構造が変更されないようにするために必要。
  - ライターミューテックスは他からの書き込みは制限するが、読み込みは制限しない。
  - サンプル（ch04/06_listing4.10_11）

感想:

ミューテックスの仕組みが理解できる。

### 第5章 条件変数とセマフォ

- **条件変数**: 条件編集はミューテックスの上に追加の機能を提供する。この機能はゴルーチンが特定の条件が発生するのを待つ状況で使用できる。
  - Goの条件変数の実装は`sync.Cond`型。Goで新たな条件変数を作るには`Locker`インテーフェイスをもったインスタンスが必要。コード例（ch05/03_listing5.3_4_5）
  - 参考: [sync package \- sync \- Go Packages](https://pkg.go.dev/sync#Cond)
  - ゴルーチンが`Signal()`もしくは`Broadcast()`を呼び出したときに`Wait()`で待機していないゴルーチンがいない場合にはそのシグナルは失われる。
  - `Signal()`は待機している中から1つのゴルーチンだけを呼び出し、`Broadcast()`は`Wait()`で待機している全てのゴルーチンを呼び出す。
  - **スターベーション**（starvation）とは、他の貪欲な実行によって資源が長時間もしくは無期限に利用できなくなり、共有資源へのアクセスを得られないない状況。（ch05/07_listing5.10）
  - スターベーションを起こさないようにするには、ゴルーチンをミューテックスで待たせる代わりに、条件変数を使って一時停止させる。
- **セマフォ**: セマフォ（semaphore）は、並行実行の許容数を指定できる点で、異なる種類の並行実行制御を提供する。
  - セマフォは共有資源へのアクセスを並行実行できるようにする固定数の許可を可能にする。全ての許可が使われると、1つの許可が再び開放されるまで、それ以上のアクセス要求は待機する必要がある。
  - ミューテックスは、排他的にアクセスできるゴルーチンが1つだけあることを保障するのに対して、セマフォは最大N個のゴルーチンがアクセスできることを保証する
  - 許可が1つしかないセマフォは、バイナリセマフォ（binary semaphore）と呼ばれる。
  - セマフォには準標準ライブラリがある [semaphore package \- golang\.org/x/sync/semaphore \- Go Packages](https://pkg.go.dev/golangorg/x/sync/semaphore)
  - 理解のための実装例（ch05/09_listing5.16､ch05/10_listing5.18）
  - 重み付けセマフォ（weighted semaphore）は、複数の許可を同時に獲得および開放するセマフォの一種（ch05/13_exam03）

感想:

条件変数とセマフォについて理解できる。

### 第6章 ウェイトグループとバリアを使った同期

- **ウェイトグループ**（weight group）と**バリア**（barrier）は、複数のゴルーチンといった実行の集まりに対して同期抽象化を行う機能のこと。
- ウェイトグループを使うと、並行タスクの集まりが完了するまでゴルーチンを待機させられる。
- Goの標準ライブラリには`sync`パッケージに`WaitGroup`型がある。この型には`Done()`, `Wait()`, `Add(delta int)`の3つのメソッドがある。
  - `Done()`: ウェイトグループのカウンタを1つ減らす。
  - `Wait()`: ウェイトグループのカウンタが0になるまで待つ
  - `Add(delta int)`: ウェイトグループのカウンタをdelta分増やす
  - 参考例（ch06/02_listing6.2）
  - 処理途中でウェイトグループのカウンタの加算が必要な例（ch06/05_listing6.5_6）
- バリアは、コード内の特定の場所でゴルーチンのグループを同期させる機能を提供する。
  - 実装によってはバリアを複数回再利用でき、再利用可能なバリアを循環式バリア（cycle barrier）と呼ぶ

感想:

ウェイトグループとバリアの使用方法や使用すべき箇所が解った。

### 第7章 メッセージパッシングを使った通信

- メッセージパッシングを使うことの利点は、誤ったプログラミングによる競合状態を引き起こすリスクを大幅に低減できること。
- チャネルは共有メモリの内容を変更しないため、ゴルーチンはメモリ上で互いに干渉することはない。
- Goのチャネルは、2つ以上のゴルーチン感でメッセージを交換することを可能にする。
- チャネルを使用するには`make()`関数を使ってチャネルを作成する。ゴルーチンを作成するときに引数として作成したチャネルを渡す。
- メッセージの送信には`<-`演算子を使う。メッセージの受信は`msg = <-messages `の様にして行う。例（ch07/01_listing7.1_2）
- ゴルーチンがメッセージをチャネルに書き込む際に、そのメッセージを読み込むゴルーチンが存在しない場合、Go
  のチャネルはデフォルトでは**同期的である**ため、送信側ゴルーチンは、メッセージを読み込む準備ができた受信側ゴルーチンが現れるまで待機させられる。
- そして、読み込み側ゴルーチンが現れない場合、Goのランタイムがデッドロックのエラーにします。例（ch07/02_listing7.3）
- また、読み込み側のゴルーチンがあるのに、書き込み側ゴルーチンが現れない場合にもGoのランタイムがエラーにします。例（ch07/03_listing7.4）
- チャネルは同期的であるが、複数のメッセージを保存するように設定でき、バッファとして使用できる。
- チャネルはバッファの容量がある限りメッセージを保存し続ける。バッファがいっぱいになった場合は書き込み側のゴルーチンは書き込みを待たされる。
- バッファに保存されたメッセージは受信側には保存順に渡される（FIFO）。バッファにメッセージがある限り受信側は待たされない。また、バッファが空になった場合にはその時点で読み込みは待たされる。例（ch07/04_listing7.5_6）
- Goのチャネルはデフォルトでは双方向であるが、方向を設定することもできる。
- 関数の引数で`messages <-chan int`のように指定する事で、チャネルの方向を指定できる。この場合は受信のみを表す。一方`messages chan<- int`は送信のみを表す。（ch07/05_listing7.7）
- **センチネル値（sentinel value）**: 実行、プロセス、またはアルゴリズム終了を指示する、予め設定された値のこと。マルチスレッド、および分散システムではポイズンピル（poison 
  pill）メッセージと呼ばれることもある。
- Goではセンチネルメッセージを使う代わりに、コードで`close(channel)`組み込み関数を呼び出すことでチャネルをクローズできる。
- チャネルがクローズするとチャネルはその型のゼロ値を返す。（ch07/06_listing7.8_9）
- チャネルからメッセージを読み込む際には、メッセージの他にチャネルの状態を示すフラグが返される。チャネルがクローズした場合にはこのフラグが`false`になる（ch07/07_listing7.10）。
- チャネルが閉じられるまでメッセージを読み込む処理は`for .. range .. {}`で反復処理ができる（ch07/08_listing7.11）。
- チャネル経由でゴルーチンで動作させた関数の結果を受け取れる（ch07/09_listing7.12_13）。

感想:

チャネルの使い方が理解できる。

### 第8章 チャネルをセレクト

- 複数チャネルからのセレクト
  - `select`文を使用することで、複数のチャネルの読み込み操作をまとめてグループ化し、何れかのチャネルにメッセージが棟立ちするまでゴルーチンを待機させられる。（ch08/01_listing8.1_2）
  - Goのこの`select`文は、プログラミング言語Newsqueakの`select`コマンド由来。参考: [Newsqueak \- Wikipedia](https://en.wikipedia.org/wiki/Newsqueak)
  - ノンブロッキング操作にチャネルを使うには、`select`文の`default:`を使用する。（ch08/02_listing8.3）
  - `default:`を使用することで、並行計算を実行できる。（ch08/03_listing8.4_5_6）
  - チャネルを使うことでタイムアウト処理を実現できる。（ch08/04_listing8.7）
  - チャネルにメッセージを書き込むときにも`select`文を使用できる。(ch08/05_listing8.8_9)
  - チャネルを`nil`にすることで`select`のケースを無効化する方法がある。この方法をnilチャネルパターンと呼ぶ。selectでチャネルがnilなケースがあった場合にはそのケースは単純に無視される。（ch08
    /07_listing8.11_12）
  - メッセージパッシングを使うか、メモリ共有を使用するかはそれぞれのオーバーヘッドを考慮し検討する必要がある。

感想:

複数のチャネルを使用する方法が解った。

### 第9章 チャネルを使ったプログラミング

- CSP
  - ミューテックスといった並行の基本操作で共有メモリを使うことは、SRCモデル（SRC model）と呼ばれることがある。
  - **CSP**（communicating sequential process）は並行システムを記述するのに使われる記述言語。メモリ共有を用いる代わりに、チャネルを介したメッセージパッシングに基づいている。
  - CSPの考え方は、Erlang, Occam, Go, ScalaのAkkaフレームワーク、Clojureのcore.async、その他多くのプログラミング言語やフレームワークの並行処理モデルに採用されている。
  - CSPでは、プロセスは値のコピーを交換することでお互いに通信する。通信は名前付きバッファ無しチャネルを介して行われる。ここでのプロセスはOSプロセスのことではなく、CSPプロセスは、それ自身の隔離された状態を持つ逐次実行のこと。
  - Go言語はゴルーチンとチャネルを使ってこのモデルを実装している。
  - CSPモデルとGoの実装の重要な違いは、Go
    ではチャネルがファーストクラスオブジェクトであると言うこと。ファーストクラスオブジェクトとは、チャネルを関数や、さらに他のチャネルに渡すことがで切ると言うこと。これによりプログラムの柔軟性が向上する。
- 一般的なチャネルパターンの再利用
  - Goでチャネルを使ってメッセージパッシングを行う場合、従うべきガイドラインが二つある。
    - チャネルに対してデータのコピーだけを渡す。
    - できるだけ、メッセージパッシングパターンとメモリ共有を混在させない。
  - quitチャネル
    - ゴルーチンにメッセージ処理の停止を指示する共通チャネルを持つパターン。
    - ゴルーチンはquitチャネルがクローズされたときに全てのメッセージ処理を中止する。
    - 例（ch09/01_listing9.1_2）
  - チャネルとゴルーチンによるパイプライン化
    - ゴルーチンをチャネルで接続して実行パイプラインを形成するパターン。
    - 例（ch09/04_listing9.7_8）
  - ファンインとファンアウト
    - Go言語のファンアウト（fan-out）並行パターンとは、複数のゴルーチンが同一チャネルより読み込むことを指す。
    - Go言語では、複数のチャネルからの内容を1つにマージする際に、ファンイン（fan-in）並行パターンが発生します。
    - 例（ch09/05_listing9.9_11）
  - クローズ時に結果を出力する
    - 例（ch09/06_listing9.12_13） 
  - 複数のゴルーチンへブロードキャストする
    - 例（ch09/07_listing9.16_17）
  - 条件成立後にチャネルをクローズする
    - 例（ch09/08_listing9.18_19）
- チャネルをファーストクラスオブジェクトとして活用
  - Goではチャネルを別のチャネルに渡すこともできる。
  - これにより線形パイプラインを使えるようになり、問題のサイズに拡張できる。
  - 例（ch09/09_listing9.20_21）

感想:

CSPとチャネルのパターンについて理解できる。
